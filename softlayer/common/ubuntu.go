package common

import (
	"bytes"
	"errors"
	"fmt"
	"html/template"
	"time"
	"sort"

	datatypes "github.com/maximilien/softlayer-go/data_types"
)

type Route struct {
	Network string
	Netmask string
	Gateway string
}

type Interface struct {
	Name                string
	Auto                bool
	AllowHotplug        bool
	DefaultGateway      bool
	SourcePolicyRouting bool
	Address             string
	Netmask             string
	Gateway             string
	Routes              []Route
	DNS                 []string
}

type Interfaces []Interface

const ETC_NETWORK_INTERFACES_TEMPLATE = `# Generated by softlayer-cpi
auto lo
iface lo inet loopback
{{ range . -}}
# {{ .Name }}
{{- if .Auto }}
auto {{ .Name }}
{{- end }}
{{- if .AllowHotplug }}
allow-hotplug {{ .Name }}
{{- end }}
iface {{ .Name }} inet static
    address {{ .Address }}
    netmask {{ .Netmask }}
    {{- if .DefaultGateway }}
    gateway {{ .Gateway }}
		{{- end }}
    {{- range $route := .Routes }}
    post-up route add -net {{ $route.Network }} netmask {{ $route.Netmask }} gw {{ $route.Gateway }}
    {{- end }}
{{- if .DNS }}
    dns-nameservers{{ range .DNS }} {{ . }}{{ end }}
{{- end }}
{{ end }}`

func (i Interfaces) Len() int           { return len(i) }
func (i Interfaces) Less(x, y int) bool { return i[x].Name < i[y].Name }
func (i Interfaces) Swap(x, y int)      { i[x], i[y] = i[y], i[x] }

func (i Interfaces) Configuration() ([]byte, error) {
	funcMap := template.FuncMap{
		"add": func(a, b int) string {
			return fmt.Sprintf("%d", a+b)
		},
	}
	t := template.Must(template.New("network-interfaces").Funcs(funcMap).Parse(ETC_NETWORK_INTERFACES_TEMPLATE))

	sort.Sort(i)
	buf := &bytes.Buffer{}
	err := t.Execute(buf, i)
	if err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

func (u *Ubuntu) NormalizeNetworkDefinitions(virtualGuest datatypes.SoftLayer_Virtual_Guest, networks Networks) (Networks, error) {
	normalized := Networks{}

	componentByNetwork, err := u.ComponentByNetworkName(virtualGuest, networks)
	if err != nil {
		return nil, err
	}

	for name, nw := range networks {
		switch nw.Type {
		case "dynamic":
			c := componentByNetwork[name]
			nw.IP = c.PrimaryIpAddress
			normalized[name] = nw
		case "manual", "":
			nw.Type = "manual"
			normalized[name] = nw
		default:
			return nil, fmt.Errorf("unexpected network type: %s", nw.Type)
		}
	}

	return normalized, nil
}

func (u *Ubuntu) NormalizeDynamics(networkComponents datatypes.SoftLayer_Virtual_Guest, networks Networks) (Networks, error) {
	var privateDynamic, publicDynamic *Network

	for _, nw := range networks {
		if nw.Type != "dynamic" {
			continue
		}

		if nw.CloudProperties.VlanID == networkComponents.PrimaryBackendNetworkComponent.NetworkVlan.Id {
			if privateDynamic != nil {
				return nil, errors.New("multiple private dynamic networks are not supported")
			}
			privateDynamic = &nw
		}

		if nw.CloudProperties.VlanID == networkComponents.PrimaryNetworkComponent.NetworkVlan.Id {
			if publicDynamic != nil {
				return nil, errors.New("multiple public dynamic networks are not supported")
			}
			publicDynamic = &nw
		}
	}

	if privateDynamic == nil {
		networks["generated-private"] = Network{
			Type:          "dynamic",
			Preconfigured: true,
			IP:            networkComponents.PrimaryBackendNetworkComponent.PrimaryIpAddress,
			CloudProperties: NetworkCloudProperties{
				VlanID:              networkComponents.PrimaryBackendNetworkComponent.NetworkVlan.Id,
				SourcePolicyRouting: true,
			},
		}
	}

	if publicDynamic == nil && networkComponents.PrimaryNetworkComponent.NetworkVlan.Id != 0 {
		networks["generated-public"] = Network{
			Type:          "dynamic",
			IP:            networkComponents.PrimaryNetworkComponent.PrimaryIpAddress,
			Preconfigured: true,
			CloudProperties: NetworkCloudProperties{
				VlanID:              networkComponents.PrimaryNetworkComponent.NetworkVlan.Id,
				SourcePolicyRouting: true,
			},
		}
	}

	return networks, nil
}

func (u *Ubuntu) ComponentByNetworkName(components datatypes.SoftLayer_Virtual_Guest, networks Networks) (map[string]datatypes.SoftLayer_Virtual_Guest_Network_Component, error) {
	componentByNetwork := map[string]datatypes.SoftLayer_Virtual_Guest_Network_Component{}

	for name, network := range networks {
		switch network.CloudProperties.VlanID {
		case components.PrimaryBackendNetworkComponent.NetworkVlan.Id:
			componentByNetwork[name] = *components.PrimaryBackendNetworkComponent
		case components.PrimaryNetworkComponent.NetworkVlan.Id:
			componentByNetwork[name] = *components.PrimaryNetworkComponent
		default:
			return nil, fmt.Errorf("Network %q specified a vlan that is not associated with this virtual guest", name)
		}
	}

	return componentByNetwork, nil
}

//go:generate counterfeiter -o fakes/fake_sl_file_service.go --fake-name FakeSLFileService . softLayerFileService
type softLayerFileService interface {
	Upload(user string, password string, target string, destinationPath string, contents []byte) error
}

//go:generate counterfeiter -o fakes/fake_ssh_client.go --fake-name FakeSSHClient . sshClient
type sshClient interface {
	Output(cmd string) ([]byte, error)
}

type Ubuntu struct {
	SSHClient            sshClient
	LinkNamer            LinkNamer
	SoftLayerFileService softLayerFileService
}

func SoftlayerPrivateRoutes(gateway string) []Route {
	return []Route{
		{Network: "10.0.0.0", Netmask: "255.0.0.0", Gateway: gateway},
		{Network: "161.26.0.0", Netmask: "255.255.0.0", Gateway: gateway},
	}
}

func (u *Ubuntu) ConfigureNetwork(interfaces Interfaces, rootPassword string, primaryBackendIP string ) error {
	config, err := interfaces.Configuration()
	if err != nil {
		return err
	}

	timeout := 5 * time.Minute
	pollingInterval := 15 * time.Second

	totalTime := time.Duration(0)
	for totalTime < timeout {
		err = u.SoftLayerFileService.Upload("root", rootPassword, primaryBackendIP, "/etc/network/interfaces.bosh", config)
		if err == nil {
			break
		}

		totalTime += pollingInterval
		time.Sleep(pollingInterval)
	}

	if err != nil {
		return err
	}

	//_, err = u.SSHClient.Output("bash -c 'ifdown -a && mv /etc/network/interfaces.bosh /etc/network/interfaces && ifup -a'")
	//if err != nil {
	//	return fmt.Errorf("nework configuration reload failed: %s", err)
	//}

	return nil
}

func (u *Ubuntu) DynamicInterfaces(networkComponents datatypes.SoftLayer_Virtual_Guest, dynamic Networks) ([]Interface, error) {
	if len(dynamic) != 1 {
		return nil, errors.New("virtual guests must have exactly one dynamic network")
	}

	nw := dynamic.First()
	privateComponent := networkComponents.PrimaryBackendNetworkComponent
	publicComponent := networkComponents.PrimaryNetworkComponent

	subnet, err := privateComponent.NetworkVlan.Subnets.Containing(privateComponent.PrimaryIpAddress)
	if err != nil {
		err = fmt.Errorf("%s: privateComponent: %#v", err, privateComponent)
		return nil, err
	}

	privateInterface := Interface{
		Name:           fmt.Sprintf("%s%d", privateComponent.Name, privateComponent.Port),
		Auto:           true,
		AllowHotplug:   true,
		Address:        privateComponent.PrimaryIpAddress,
		Netmask:        subnet.Netmask,
		Gateway:        subnet.Gateway,
		DefaultGateway: (publicComponent.PrimaryIpAddress == "" && nw.HasDefaultGateway()),
		Routes:         SoftlayerPrivateRoutes(subnet.Gateway),
	}
	interfaces := []Interface{privateInterface}

	if publicComponent.PrimaryIpAddress != "" {
		for _, s := range publicComponent.NetworkVlan.Subnets {
			if s.Contains(publicComponent.PrimaryIpAddress) {
				subnet = s
				break
			}
		}
		publicInterface := Interface{
			Name:           fmt.Sprintf("%s%d", publicComponent.Name, publicComponent.Port),
			Auto:           true,
			AllowHotplug:   true,
			Address:        publicComponent.PrimaryIpAddress,
			Netmask:        subnet.Netmask,
			Gateway:        subnet.Gateway,
			DefaultGateway: nw.HasDefaultGateway(),
		}
		interfaces = append(interfaces, publicInterface)
	}

	return interfaces, nil
}

func (u *Ubuntu) ManualInterfaces(networkComponents datatypes.SoftLayer_Virtual_Guest, networks Networks) ([]Interface, error) {
	privateComponent := networkComponents.PrimaryBackendNetworkComponent
	publicComponent := networkComponents.PrimaryNetworkComponent

	interfaces := []Interface{}
	for networkName, nw := range networks {
		if subnet, err := privateComponent.NetworkVlan.Subnets.Containing(nw.IP); err == nil {
			intf := Interface{
				Name:           fmt.Sprintf("%s%d:%s", privateComponent.Name, privateComponent.Port, networkName),
				Auto:           true,
				AllowHotplug:   true,
				Address:        nw.IP,
				Netmask:        subnet.Netmask,
				Gateway:        subnet.Gateway,
				DefaultGateway: nw.HasDefaultGateway(),
				Routes:         SoftlayerPrivateRoutes(subnet.Gateway),
			}

			interfaces = append(interfaces, intf)
			continue
		}

		if subnet, err := publicComponent.NetworkVlan.Subnets.Containing(nw.IP); err == nil {
			intf := Interface{
				Name:           fmt.Sprintf("%s%d:%s", publicComponent.Name, publicComponent.Port, networkName),
				Auto:           true,
				AllowHotplug:   true,
				Address:        nw.IP,
				Netmask:        subnet.Netmask,
				Gateway:        subnet.Gateway,
				DefaultGateway: nw.HasDefaultGateway(),
			}

			interfaces = append(interfaces, intf)
			continue
		}

		return nil, errors.New("manual subnet not found")
	}

	return interfaces, nil
}

//go:generate counterfeiter -o fakes/fake_link_namer.go --fake-name FakeLinkNamer . LinkNamer
type LinkNamer interface {
	Name(interfaceName, networkName string) (string, error)
}

type indexedNamer struct {
	indices map[string]int
}

func NewIndexedNamer(networks Networks) LinkNamer {
	indices := map[string]int{}

	index := 0
	for name := range networks {
		indices[name] = index
		index++
	}

	return &indexedNamer{
		indices: indices,
	}
}

func (l *indexedNamer) Name(interfaceName, networkName string) (string, error) {
	idx, ok := l.indices[networkName]
	if !ok {
		return "", fmt.Errorf("Network name not found: %q", networkName)
	}

	return fmt.Sprintf("%s:%d", interfaceName, idx), nil
}
